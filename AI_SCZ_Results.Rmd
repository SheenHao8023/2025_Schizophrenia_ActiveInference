---
title: "AI_SCZ_Results"
author: "XinHao"
date: "2025-09-20"
output: html_document
---

## 使用到的包
```{r packages}
packages <- c("ggprism", "ggsci", "ggpubr", "ggplot2", "dplyr", "tidyr", "readr", "readxl", "openxlsx", "stringr", "ggExtra", "bruceR", "emmeans", "corrplot", "patchwork","tidyverse",
"fitdistrplus", "transport", "philentropy")  
for (pkg in packages) {
  if (!require(pkg, character.only = TRUE)) {
    install.packages(pkg, dependencies = TRUE)
    library(pkg, character.only = TRUE)
  } else {
    library(pkg, character.only = TRUE)
  }
}
set.seed(8023) 
```

## 计算归一化后的指标并写入
```{r index}
########### Computing and normalizing index ###########
raw_dir <- "C:/Users/XinHao/Desktop/2025_SCZ_AI/empirical_data/behav_rawfiles"
main_file <- "C:/Users/XinHao/Desktop/2025_SCZ_AI/empirical_data/data_behav&sympt.xlsx"
basepath = 'C:/Users/XinHao/Desktop/2025_SCZ_AI/empirical_data/'
file_list <- list.files(raw_dir, pattern = "\\.xlsx$", full.names = TRUE)
mean_values <- data.frame(SubID = character(), IC = numeric(), WS = numeric(), stringsAsFactors = FALSE)

for (file in file_list) {
  sub_id <- str_extract(basename(file), "\\d{5}")
  dat <- read_excel(file)
  ic_mean <- mean(dat$IC, na.rm = TRUE)
  ws_mean <- mean(dat$WS, na.rm = TRUE)
  wsearlier_mean <- mean(dat$WSearlier, na.rm = TRUE)
  rd_mean <- mean(dat$RDearlier, na.rm = TRUE)
  mean_values <- rbind(mean_values, data.frame(SubID = sub_id, IC = ic_mean, WS = ws_mean, 
                                               WSearlier = wsearlier_mean, RDearlier = rd_mean))
}

main_data <- read.xlsx(main_file)
main_data <- main_data %>%
  left_join(mean_values, by = "SubID") %>%
  {df <- .
    if ("IC.y" %in% names(df)) {
      df <- df %>%
        dplyr::select(-any_of(c("IC.x", "WS.x", "WSearlier.x", "RDearlier.x"))) %>%
        rename(IC = IC.y, WS = WS.y,  WSearlier = WSearlier.y, RDearlier = RDearlier.y)}
    df %>%
      mutate(
        IC_scaled = 1 / (1 + exp(-scale(IC))),
        WS_scaled = 1 / (1 + exp(-scale(WS))),
        WSearlier_scaled = 1 / (1 + exp(-scale(WSearlier))),
        RDearlier_scaled = 1 / (1 + exp(-scale(RDearlier))))}
write.xlsx(main_data, main_file, overwrite = TRUE)
```

```{r statsfunc}
# 通用卡方检验置换检验函数（支持多分类变量）
chi_square_perm_test <- function(data, var, group_var = "Group2", B = 1000) {
  tab <- table(data[[group_var]], data[[var]])
  complete_cases <- complete.cases(data[[group_var]], data[[var]])
  data_complete <- data[complete_cases, ]
  tab <- table(data_complete[[group_var]], data_complete[[var]])
  n <- sum(tab)
  r <- nrow(tab)  # 组数
  c <- ncol(tab)  # 变量类别数
  cat("列联表维度:", r, "×", c, "\n")
  chi_real <- chisq.test(tab, simulate.p.value = n < 50)
  chi_stat_real <- chi_real$statistic
  p_real <- chi_real$p.value
  cramer_v_real <- sqrt(chi_stat_real / (n * (min(r, c) - 1)))  #效应量
  
  perm_stats <- numeric(B)
  for (i in 1:B) {
    perm_groups <- sample(data_complete[[group_var]])
    tab_perm <- table(perm_groups, data_complete[[var]])
    chi_perm <- suppressWarnings(chisq.test(tab_perm, simulate.p.value = FALSE))
    perm_stats[i] <- chi_perm$statistic
  }
  
  p_perm <- mean(perm_stats >= chi_stat_real)
  list(variable = var,chi_square = as.numeric(chi_stat_real),df = chi_real$parameter,
      p_value = p_real,p_permutation = p_perm,cramers_v = cramer_v_real,contingency_table = tab,
      n = n,dimensions = c(r, c), B = B)
}

# 优化卡方检验打印函数（支持多分类变量）
print_chi_result <- function(res) {
  cat("\n", rep("=", 70), "\n", sep = "")
  cat("变量:", res$variable, "(", res$dimensions[1], "×", res$dimensions[2], "表格)\n")
  cat(rep("-", 70), "\n", sep = "")
  
  cat("列联表（频数）:\n")
  print(res$contingency_table)
  cat("\n行百分比(%):\n")
  prop_tab <- prop.table(res$contingency_table, margin = 1) * 100
  print(round(prop_tab, 1))
  
  cat(sprintf("\n卡方检验: χ²(%.0f) = %.2f, p = %.3f", res$df, res$chi_square, res$p_value))
  cat(sprintf("\n置换检验: p = %.4f (基于%d次置换)", res$p_permutation, res$B))
  cat(sprintf("\n效应量: Cramér's V = %.3f", res$cramers_v))
  cat("样本量: n =", res$n, "\n")
  
  # 检查期望频数（对于多分类变量很重要）
  expected <- chisq.test(res$contingency_table)$expected
  min_expected <- min(expected)
  cat("最小期望频数:", round(min_expected, 2))
  if (min_expected < 5) {
    cat(" ⚠️  (注意：有期望频数小于5的单元格)\n")
  } else {
    cat(" ✓\n")
  }
  
  cat(rep("=", 70), "\n\n", sep = "")
}

# 2-paired sample Wilcoxon Permutation Test
wilcoxon_perm_test <- function(df, var1, var2, B = 1000) {
  test_real <- wilcox.test(df[[var1]], df[[var2]], paired = TRUE, exact = FALSE, correct = FALSE)
  W_real <- test_real$statistic
  diffs <- df[[var1]] - df[[var2]]
  n <- sum(!is.na(diffs))
  mu_w <- n*(n+1)/4
  
  W_perm <- replicate(B, {
    s <- sample(c(1,-1), n, replace = TRUE)
    d <- s * abs(diffs)           # 符号翻转法
    as.numeric(wilcox.test(d, mu = 0, exact = FALSE, correct = FALSE)$statistic)
  })
  p_val <- (sum(abs(W_perm - mu_w) >= abs(W_real - mu_w)) + 1) / (B + 1)
  list(W = W_real, p = p_val, n = n, mean_diff = mean(diffs, na.rm = TRUE))
}

# 2-independent sample Mann-Whitney Permutation Test  独立分组
mannwhitney_perm_test <- function(df, var, group_var = "Group2", g1, g2, B = 1000) {
  df <- df[!is.na(df[[var]]) & !is.na(df[[group_var]]), c(var, group_var)]
  x <- df[[var]][df[[group_var]] == g1]
  y <- df[[var]][df[[group_var]] == g2]
  n1 <- length(x)
  n2 <- length(y)
  
  # 合并样本，计算秩
  combined <- c(x, y)
  ranks <- rank(combined, ties.method = "average")
  R1 <- sum(ranks[1:n1])
  R2 <- sum(ranks[(n1+1):(n1+n2)])
  U1 <- n1*n2 + n1*(n1+1)/2 - R1
  U2 <- n1*n2 + n2*(n2+1)/2 - R2
  U_real <- min(U1, U2)  # 永远非负
  mu_u <- n1*n2/2        # 期望胜出次数
  
  u_perm <- numeric(B)
  total_n <- n1 + n2
  for(i in 1:B) {
    perm_sample <- sample(combined, total_n, replace = FALSE)
    ranks_perm <- rank(perm_sample, ties.method = "average")
    R1p <- sum(ranks_perm[1:n1])
    R2p <- sum(ranks_perm[(n1+1):total_n])
    U1p <- n1*n2 + n1*(n1+1)/2 - R1p
    U2p <- n1*n2 + n2*(n2+1)/2 - R2p
    u_perm[i] <- min(U1p, U2p)
  }
  p_val <- (sum(abs(u_perm - mu_u) >= abs(U_real - mu_u)) + 1) / (B + 1)
  r_rb <- abs(2*U_real/(n1*n2) - 1) # 效应量rank-biserial correlation的绝对值
  list(U = U_real, p = p_val, n1 = n1, n2 = n2, r_rb = r_rb)
}

# 3-sample Kruskal-Wallis Permutation Test
kruskal_perm_test <- function(data, var, group_var = "Group2", B = 1000) {
  f <- as.formula(paste(var, "~", group_var))
  kw <- kruskal.test(f, data = data)
  n <- sum(!is.na(data[[var]]))
  k <- length(unique(na.omit(data[[group_var]])))
  eta2 <- (kw$statistic - (k - 1)) / (n - 1)  # 效应量
  if (eta2 < 0) eta2 <- 0 
  perm_stats <- replicate(B, {
    data_perm <- data
    data_perm[[group_var]] <- sample(data_perm[[group_var]])
    kruskal.test(f, data = data_perm)$statistic
  })
  
  p_value <- mean(perm_stats >= kw$statistic)  #单侧检验
  if (p_value == 0) p_value <- 1/(B+1)  
  sig <- p_value < 0.05
  res <- list(var = var, kw_stat = kw$statistic, kw_p = p_value, sig = sig,
              groups = unique(data[[group_var]]),eta2 = as.numeric(eta2))
  
  # 如果显著则进行两两比较
  if (sig && length(res$groups) >= 2) {
    pairs <- combn(res$groups, 2, simplify = FALSE)
    pair_results <- list()
    for (i in seq_along(pairs)) {
      p <- pairs[[i]]
      test <- mannwhitney_perm_test(data, var, g1 = p[1], g2 = p[2], B = B)
      pair_results[[i]] <- list(pair = paste(p[1], p[2], sep = " vs "),U = test$U,raw_p = test$p,
                                n1 = test$n1,n2 = test$n2)
    }
    
    raw_ps <- sapply(pair_results, function(x) x$raw_p)
    adj_ps <- p.adjust(raw_ps, method = "bonferroni")  # Bonferroni校正
    for (i in seq_along(pair_results)) {
      pair_results[[i]]$adj_p <- adj_ps[i]
      pair_results[[i]]$sig <- adj_ps[i] < 0.05
    }
    res$pairwise <- pair_results
  }
  return(res)
}

# 优化KW单向方差分析打印函数
print_kw_result <- function(res) {
  cat("\n", rep("=", 50), "\n", sep = "")
  cat("变量:", res$var, "\n")
  cat(rep("-", 50), "\n", sep = "")
  cat(sprintf("Kruskal-Wallis检验: H = %.2f, p = %.3f, eta² = %.3f", 
              res$kw_stat, res$kw_p, res$eta2))
  cat(ifelse(res$sig, " (显著)*\n", " (不显著)\n"))
  cat("各组样本量: ")
  group_counts <- table(main_data$Group2[!is.na(main_data[[res$var]])])
  cat(paste(names(group_counts), "=", group_counts, collapse = ", "), "\n")
  if (res$sig && !is.null(res$pairwise)) {
    cat("\n两两比较 (Bonferroni校正):\n")
    cat(rep("-", 30), "\n", sep = "")
    for (p in res$pairwise) {
      sig_symbol <- ifelse(p$sig, "*", "")
      cat(sprintf("%-20s: U = %6.1f, raw_p = %6.4f, adj_p = %6.4f%s\n",
                  p$pair, p$U, p$raw_p, p$adj_p, sig_symbol))
    }
  }
  cat(rep("=", 50), "\n\n", sep = "")
}
```


```{r Demochi2test}
variables <- c("Gender(1m2f)", "Education(1a2b)", "NumDrugs")  # 可以添加多分类变量
B = 1000
cat("开始卡方置换检验（支持多分类变量）...\n")
results <- list()
for (var in variables) {
  if (var %in% names(main_data)) {
    cat("\n正在分析变量:", var, "\n")
    res <- chi_square_perm_test(main_data, var)
    print_chi_result(res)
    results[[var]] <- res
  } else {
    cat("\n变量", var, "不存在于数据中，跳过\n")
  }
}
```


```{r SymptomsA, results='asis'}
########### EmpiricalPlot_SymptomsRaw #############
main_data$`PANSS_P1.+.P3.(psychotic)` <- as.numeric(main_data$`PANSS_P1.+.P3.(psychotic)`)
main_data$`PANSS_N2.+.N4.(withdrawal)` <- as.numeric(main_data$`PANSS_N2.+.N4.(withdrawal)`)
main_data$`PANSS_N1.(blunted.affect)` <- as.numeric(main_data$`PANSS_N1.(blunted.affect)`)
main_data$PANSS_Total <- as.numeric(main_data$PANSS_Total)
data <- data.frame( 
  "A" = c(main_data$`PANSS_P1.+.P3.(psychotic)`[25:32], 0,  main_data$`PANSS_P1.+.P3.(psychotic)`[25:32], main_data$`PANSS_P1.+.P3.(psychotic)`[17:24]),
  "B" = c(main_data$`PANSS_N2.+.N4.(withdrawal)`[25:32], 0,  main_data$`PANSS_N2.+.N4.(withdrawal)`[25:32],main_data$`PANSS_N2.+.N4.(withdrawal)`[17:24]),
  "C" = c(main_data$`PANSS_N1.(blunted.affect)`[25:32]*2, 0,  main_data$`PANSS_N1.(blunted.affect)`[25:32]*2, main_data$`PANSS_N1.(blunted.affect)`[17:24]*2))
data$Group <- c(rep("BA", 4), rep("WD",4), rep('NA', 1), rep("NS", 8), rep("PS", 8))
data_long <- data %>%
  pivot_longer(cols = -Group, names_to = "Metric", values_to = "Value")
summary_data <- data_long %>%
  group_by(Metric, Group) %>%
  summarise(mean = mean(Value), n=n(), se = sd(Value)/sqrt(n()), .groups = 'drop')
summary_data$se[summary_data$Group %in% c("BA", "WD")] <- NA  #不添加亚组的errorbar
levels(summary_data$Metric) <- c("A", "B", "C")
summary_data$Group <- factor(summary_data$Group, levels = c('BA','WD','NA','NS','PS'))
data_long$Group <- factor(data_long$Group, levels = c('BA','WD','NA','NS','PS'))
summary_data$Metric <- factor(summary_data$Metric, levels = c("A", "B", "C"))
SymptomsRaw <- ggplot(summary_data, aes(x = Group, y = mean, fill = Metric)) +
  geom_bar(stat = "identity", position = position_dodge(width = 0.9), width = 0.7, colour = NA) + 
  geom_errorbar(aes(ymin = mean - se, ymax = mean + se), width = 0.4, position = position_dodge(width = 0.9), linewidth = 0.7, na.rm = TRUE) + 
  geom_jitter(data = subset(data_long, Group != 'NA'), aes(x = Group, y = Value), 
              position = position_jitterdodge(jitter.width = 0.1, dodge.width = 0.7), alpha = 1, color = 'black', size = 1) + 
  scale_fill_manual(values = c('#fc8d62','#8da0cb','#6495ed'), name = "Items", labels = c("P1+P3", "N2+N4", "2N1")) + 
  scale_x_discrete(breaks = c('PS','NS','BA','WD'), labels = c('PS', 'NS', 'BA', 'WD')) + 
  coord_cartesian(ylim = c(0, 10)) +
  labs(x = NULL, y = "Raw Scores") +
  theme_prism(axis_text_angle = 0)+ 
  theme(legend.direction = "vertical", legend.position = 'right',
        #panel.grid = element_blank(),
        axis.line = element_line(color = 'black', size = 0.75),
        axis.ticks = element_line(color = 'black', size = 0.75),
        axis.text = element_text(size = 12, color = "black", face = 'plain'),  
        axis.title = element_text(size = 14, face = 'plain')) +
  geom_rect(aes(xmin=0.5, xmax=2.5,ymin=-0.2,ymax=10.45), fill = NA, color='black', linetype = 'dashed', size=0.75) + 
  geom_rect(aes(xmin=3.5, xmax=4.5,ymin=-0.2,ymax=10.45), fill = NA, color='black', linetype = 'dashed', size=0.75)
ggsave(filename = file.path(basepath, "EmpiricalPlot_SymptomsRaw.png"),  width = 6, height = 4, dpi = 500)
print(SymptomsRaw)
```

```{r SymptomsB, results='asis'}
########### EmpiricalPlot_SymptomsRelative #############
main_data$`PANSS_P1.+.P3.(psychotic)` <- as.numeric(main_data$`PANSS_P1.+.P3.(psychotic)`)
main_data$`PANSS_N2.+.N4.(withdrawal)` <- as.numeric(main_data$`PANSS_N2.+.N4.(withdrawal)`)
main_data$`PANSS_N1.(blunted.affect)` <- as.numeric(main_data$`PANSS_N1.(blunted.affect)`)
main_data$PANSS_Total <- as.numeric(main_data$PANSS_Total)
data <- data.frame( 
  "A" = c(main_data$`PANSS_P1.+.P3.(psychotic)`[17:24]/(2*main_data$PANSS_Total[17:24]), 0,  main_data$`PANSS_P1.+.P3.(psychotic)`[25:32]/(2*main_data$PANSS_Total[25:32])),
  "B" = c((main_data$`PANSS_N2.+.N4.(withdrawal)`[17:24] + main_data$`PANSS_N1.(blunted.affect)`[17:24])/(3*main_data$PANSS_Total[17:24]), 
          0, (main_data$`PANSS_N2.+.N4.(withdrawal)`[25:32] + main_data$`PANSS_N1.(blunted.affect)`[25:32])/(3*main_data$PANSS_Total[25:32])))
data$Group <- c(rep("PS", 8), rep('NA', 1), rep("NS", 8))
data_long <- data %>%
  pivot_longer(cols = -Group, names_to = "Metric", values_to = "Value")
summary_data <- data_long %>%
  group_by(Metric, Group) %>%
  summarise(mean = mean(Value), n=n(), se = sd(Value)/sqrt(n()), .groups = 'drop')
levels(summary_data$Metric) <- c("A", "B")
summary_data$Group <- factor(summary_data$Group, levels = c('PS','NA','NS'))
data_long$Group <- factor(data_long$Group, levels = c('PS','NA','NS'))
summary_data$Metric <- factor(summary_data$Metric, levels = c("A", "B"))
SymptomsRelative <- ggplot(summary_data, aes(x = Group, y = mean, fill = Metric)) +
  geom_bar(stat = "identity", position = position_dodge(width = 0.9), width = 0.7, colour = NA) + 
  geom_errorbar(aes(ymin = mean - se, ymax = mean + se), width = 0.4, position = position_dodge(width = 0.9), linewidth = 0.7, na.rm = TRUE) + 
  geom_jitter(data = subset(data_long, Group != 'NA'), aes(x = Group, y = Value), 
              position = position_jitterdodge(jitter.width = 0.1, dodge.width = 0.7), alpha = 1, color = 'black', size = 1) + 
  scale_fill_manual(values = c('#fc8d62','#4169E1'), name = "Items", labels = c("(P1+P3)/2", "(N2+N4+N1)/3")) + 
  scale_x_discrete(breaks = c('PS','NS'), labels = c('PS', 'NS')) + 
  coord_cartesian(ylim = c(0, 0.08)) +
  labs(x = NULL, y = "Relative Scores") +
  theme_prism(axis_text_angle = 0)+ 
  theme(legend.direction = "vertical", legend.position = 'right',
        #panel.grid = element_blank(),
        axis.line = element_line(color = 'black', size = 0.75),
        axis.ticks = element_line(color = 'black', size = 0.75),
        axis.text = element_text(size = 12, color = "black", face = 'plain'),  
        axis.title = element_text(size = 14, face = 'plain')) 
ggsave(filename = file.path(basepath, "EmpiricalPlot_SymptomsRelative.png"),  width = 5, height = 4, dpi = 500)
print(SymptomsRelative)
```

## PANSS总分柱状图
```{r SymptomsC, results='asis'}
# PANSS_Total bar plot
main_data$PANSS_Total <- as.numeric(main_data$PANSS_Total)
data <- data.frame(
  "PANSS_Total" = c(main_data$PANSS_Total[25:32], main_data$PANSS_Total[17:24]),
  "Group" = c(rep("PS", 8), rep("NS", 8))
)
data_long <- data %>%
  pivot_longer(cols = -Group, names_to = "Metric", values_to = "Value")
summary_data <- data_long %>%
  group_by(Metric, Group) %>%
  summarise(mean = mean(Value), n = n(), se = sd(Value)/sqrt(n()), .groups = 'drop')
summary_data$Group <- factor(summary_data$Group, levels = c('PS', 'NS'))
data_long$Group <- factor(data_long$Group, levels = c('PS', 'NS'))
PANSS_Total_Plot <- ggplot(summary_data, aes(x = Group, y = mean, fill = Group)) +
  geom_bar(stat = "identity", position = position_dodge(width = 0.9), 
           width = 0.7, colour = NA) + 
  geom_errorbar(aes(ymin = mean - se, ymax = mean + se), 
                width = 0.4, position = position_dodge(width = 0.9), 
                linewidth = 0.7, na.rm = TRUE) + 
  geom_jitter(data = data_long, aes(x = Group, y = Value, fill = Group), 
              position = position_jitter(width = 0.2), 
              alpha = 1, fill = 'black', color = 'black', size = 1.5, shape = 21) + 
  scale_fill_manual(values = c('PS' = '#fc8d62', 'NS' = '#4169E1'), 
                    name = "Group", labels = c('PS', 'NS')) + 
  scale_x_discrete(labels = c('PS', 'NS')) + 
  coord_cartesian(ylim = c(0, 100)) +
  labs(x = NULL, y = "PANSS Total Score") +
  theme_minimal() +
  theme(legend.position = 'none',  # 隐藏图例，因为x轴已经标注了组别
    axis.line = element_line(color = 'black', size = 0.75),
    axis.ticks = element_line(color = 'black', size = 0.75),
    axis.text = element_text(size = 12, color = "black", face = 'plain'),  
    axis.title = element_text(size = 14, face = 'plain'),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.background = element_blank()
  )
ggsave(filename = file.path(basepath, "EmpiricalPlot_PANSSTotal.png"), width = 1.5, height = 4, dpi = 500)
print(PANSS_Total_Plot)


```

## 症状学指标的非参数置换检验统计
```{r SymptomsTest}
main_data$Group2 <- ifelse(main_data$Group %in% c("NS_BA", "NS_WD"), "NS", main_data$Group)
main_data$PANSS_Positive_ave <- main_data$`PANSS_P1.+.P3.(psychotic)`/2
main_data$PANSS_Negative_ave <- (main_data$`PANSS_N2.+.N4.(withdrawal)` + main_data$`PANSS_N1.(blunted.affect)`) /3

# 应用到 PS 和 NS 组
for (g in c("PS", "NS")) {
  group_data <- subset(main_data, Group2 == g)
  group_data <- group_data[!is.na(group_data$PANSS_Positive_ave) & !is.na(group_data$PANSS_Negative_ave), ]
  res <- wilcoxon_perm_test(group_data, "PANSS_Positive_ave", "PANSS_Negative_ave")
  cat("====", g, "组 PANSS阳性 vs 阴性平均分比较 ====\n")
  cat("样本量: n =", res$n, "\n")
  cat("平均差异:", round(res$mean_diff, 3), "\n")
  cat("W统计量 =", round(res$W, 3), "\n")
  cat("p值 =", format.pval(res$p, digits = 4, eps = 0.0001), "\n")
}

# 应用到3个与筛选相关的PANSS项目得分变量
cat("=== 组内分析 PANSS筛选相关变量 ===\n")
for (var in c("PANSS_Positive_ave", "PANSS_Negative_ave", "PANSS_Total")) {
  res <- mannwhitney_perm_test(main_data, var, g1 = "PS", g2 = "NS")
  cat("变量:", var, 
      "| U =", round(res$U, 2), 
      "| p =", format.pval(res$p, digits = 3, eps = 0.0001),
      "| n(PS) =", res$n1,
      "| n(NS) =", res$n2, 
      "| ES =", round(res$r_rb, 3), "\n")
}

# 应用到症状学表格
cat("\n=== 症状学表格变量 ===\n")
for (var in c("OZP(mg/day)", "PANSS_Total", "PANSS_Positive", "PANSS_Negative", 
              "PosiDimension", "NegaDimension", "PANSS_P1.+.P3.(psychotic)", 
              "PANSS_N2.+.N4.(withdrawal)", "PANSS_N1.(blunted.affect)", "RSESE")) {
  res <- mannwhitney_perm_test(main_data, var, g1 = "PS", g2 = "NS")
  cat("变量:", var, 
      "| U =", round(res$U, 2), 
      "| p =", format.pval(res$p, digits = 3, eps = 0.0001),
      "| n(PS) =", res$n1,
      "| n(NS) =", res$n2, 
      "| ES =", round(res$r_rb, 3), "\n")
}
```

## 建立行为数据绘图函数
```{r BehaviorPlots, results='asis'}
############### EmpiricalPlots, FigX ###################
plot_empirical <- function(data_column, y_label, file_name, height) {
  data <- data.frame(
    group = factor(
      c(rep('HC',16), rep('PS',8), rep('NS',8), rep('NA',1), rep('BA',4), rep('WD',4)),
      levels = c('HC','PS','NS','NA','BA','WD')),
    exp = c(main_data[[data_column]][1:16], main_data[[data_column]][17:24],
            main_data[[data_column]][25:32],  0,
            main_data[[data_column]][25:28],  main_data[[data_column]][29:32]))
  
  p <- ggplot(data = data, mapping = aes(x = factor(group), y = exp, fill = group)) +
    stat_summary(fun = "mean", geom = "bar", width = 0.7, colour = NA, size = 0.9) +
    geom_jitter(data = subset(data, group != 'NA'), size = 1) +
    stat_summary(fun = "mean", fun.max = function(x) mean(x) + sd(x),
                 fun.min = function(x) mean(x) - sd(x), geom = "errorbar", width = 0.4, size = 0.7) +
    theme_prism(axis_text_angle = 0) +
    theme(legend.direction = "vertical",
          axis.line = element_line(color = 'black', size = 0.75),
          axis.ticks = element_line(color = 'black', size = 0.75),
          axis.text = element_text(size = 12, color = "black", face = 'plain'),
          axis.title = element_text(size = 14, face = 'plain')) +
    coord_cartesian(ylim = c(0, 1.05)) +
    scale_fill_manual(values = c('#66c2a5','#fc8d62','#8da0cb', 'transparent', '#e78ac3','#a6d854')) +
    scale_x_discrete(breaks = c('HC','PS','NS','BA','WD'), labels = c('HC','PS','NS','BA','WD')) +
    labs(x = NULL, y = y_label) +
    geom_rect(aes(xmin = 2.5, xmax = 3.5, ymin = -0.02, ymax = height),
              fill = NA, color = 'black', linetype = 'dashed', size = 0.75) +
    geom_rect(aes(xmin = 4.5, xmax = 6.5, ymin = -0.02, ymax = height),
              fill = NA, color = 'black', linetype = 'dashed', size = 0.75)
  
  ggsave(filename = file.path(basepath, file_name), plot = p, width = 5, height = 4, dpi = 500)
  print(p)
}
```

## 行为指标统计图展示
```{r showBehaviorPlots, results='asis'}
plot_empirical("IC_scaled", "IC", "EmpiricalPlot_IC.png", 0.4)
plot_empirical("WS_scaled", "WS", "EmpiricalPlot_WS.png", 0.7)
plot_empirical("WSearlier_scaled", "WS with metronome", "EmpiricalPlot_WSearlier.png", 0.85)
plot_empirical("RDearlier_scaled", "RD with metronome", "EmpiricalPlot_RDearlier.png", 1.05)
```

## 三组之间的统计检验
```{r stat-posthoc}
variables <- c("Age", "ISI", "BDI", "IRI_Fantasy", "IRI_EmpathicConcern", "IRI_Perspective",  
               "IRI_PersonalDistress", "UCLA", "PSP", "LSAS_Anxiety", "LSAS_Avoidance",
               "SQLS_MotivationEnergy", "SQLS_SymptomSideeffect", "SQLS_PsychosocialFacet", 
               "Token.Motor.Task", "Digit.Symbol.Test", "Digit.Span.Test_sequence", 
               "Digit.Span.Test_reverse", "Digit.Span.Test_sum",  "RDearlier_scaled", "WSearlier_scaled", 
               "IC_scaled", "WS_scaled", "FirstTappingIC", "FirstTappingWS",
               "QuestionnaireIC", "QuestionnaireWS")
cat("开始Kruskal-Wallis置换检验...\n")
for (var in variables) {
  res <- kruskal_perm_test(main_data, var)
  print_kw_result(res)
}
```
## 绘制时序概率图
```{r hiddenstates, results='asis'}
hiddenstateprobs <- read.csv("C:/Users/XinHao/Desktop/2025_SCZ_AI/simulation/hiddenstateprobs.csv")
group_colors <- c('HC' = '#66c2a5','PS' = '#fc8d62','NS' = '#8da0cb','BA' = '#e78ac3','WD' = '#a6d854')

plot_hidden_state <- function(data, groups) {
  data_filtered <- data %>%
    filter(group %in% groups) %>%
    mutate(group = as.factor(group))
  ggplot(data_filtered, aes(x = t, y = probability, color = group)) +
    geom_line() +
    scale_color_manual(values = group_colors) +
    geom_hline(yintercept = 0.5, linetype = "dotted", color = "black") +
    facet_wrap(~ state, ncol = 1) +
    labs(x = "Timepoint", y = "Hidden State Probability") +
    scale_x_continuous(breaks = seq(1, 24, by = 1)) +
    scale_y_continuous(limits = c(0.4, 1), breaks = seq(0.4, 1, by = 0.1)) +
    theme_minimal(base_size = 18) +
    theme(legend.position = "none")
}

p1 <- plot_hidden_state(hiddenstateprobs, c("HC", "PS", "NS"))
p2 <- plot_hidden_state(hiddenstateprobs, c("HC", "PS", "BA", "WD"))
combined_plot <- p1 + p2 + plot_layout(ncol = 2)
print(combined_plot)
ggsave("C:/Users/XinHao/Desktop/2025_SCZ_AI/simulation/Hiddenstates_Plot.png",
       combined_plot, width = 16, height = 8, dpi = 300)
```

## singleshot作图函数
```{r ssplot}
############### SingleShot_Plots, FigX ###################
file_path <- "C:/Users/XinHao/Desktop/2025_SCZ_AI/simulation/"
group_levels <- c("HC", "PS", "NS", "NA", "BA", "WD")
fill_colors <- c('#66c2a5','#fc8d62','#8da0cb', 'transparent', '#e78ac3','#a6d854')

plot_metric <- function(metric_name, empirical_values, filename, ylim_max, rect_ymax) {
  # empirical data
  emp_data <- data.frame(
    group = factor(rep(group_levels, times = c(16,8,8,1,4,4)), levels = group_levels),
    exp = empirical_values
  )
  emp_summary <- emp_data %>%
    group_by(group) %>%
    summarise(Mean = mean(exp, na.rm=TRUE), SD = sd(exp, na.rm=TRUE))
  emp_summary[emp_summary$group == "NA", "SD"] <- 0
  print(emp_summary[, c("group", "Mean", "SD")])
  
  # load simulation data
  sim_data <- read_csv(paste0(file_path, 'simulated_performance_ss26Aug2025.csv')) %>%
    filter(group %in% group_levels) %>%
    mutate(group = factor(group, levels = group_levels))
  
  data_summary <- sim_data %>%
    filter(group %in% c("HC", "PS", "NS", "BA", "WD")) %>%
    group_by(group) %>%
    summarise(mean_bar = mean(.data[[metric_name]], na.rm = TRUE), .groups = "drop")
  data_summary <- rbind(data_summary[1:3, ], data.frame(group = 'NA', mean_bar = 0), data_summary[4:5, ])
  data_summary$group <- factor(data_summary$group, levels = group_levels)
  
  p <- ggplot(data = data_summary, aes(x = group, y = mean_bar, fill = group)) +
    geom_bar(stat = 'identity', position = 'dodge', width = 0.7) +
    geom_point(data = subset(emp_summary, group != 'NA'), aes(x = group, y = Mean, fill = group), size = 1.25) +
    geom_errorbar(data = subset(emp_summary, group != 'NA'), 
                  aes(x = group, ymin = Mean - SD, ymax = Mean + SD), 
                  inherit.aes = FALSE, width = 0.4, size = 0.5, color = "black") +
    theme_prism(axis_text_angle = 0) +
    theme(
      legend.direction = "vertical",
      axis.line = element_line(color = 'black', size = 0.75),
      axis.ticks = element_line(color = 'black', size = 0.75),
      axis.text = element_text(size = 12, color = "black", face = 'plain'),
      axis.title = element_text(size = 14, face = 'plain')
    ) +
    coord_cartesian(ylim = c(0, ylim_max)) +
    scale_fill_manual(values = fill_colors) +
    scale_x_discrete(breaks = c("HC", "PS", "NS", "BA", "WD"), labels = c("HC", "PS", "NS", "BA", "WD")) +
    labs(x = NULL, y = metric_name) +
    geom_rect(aes(xmin = 2.5, xmax = 3.5, ymin = -0.02, ymax = rect_ymax), fill = NA, color = 'black', linetype = 'dashed', size = 0.5) +
    geom_rect(aes(xmin = 4.5, xmax = 6.5, ymin = -0.02, ymax = rect_ymax), fill = NA, color = 'black', linetype = 'dashed', size = 0.5)
  ggsave(filename = file.path(file_path, filename), plot = p, width = 5, height = 4, dpi = 500)
  print(p)
}
```

## SS统计图展示
```{r showSSplot, results='asis'}
# 1. IC 
emp_values_IC <- c(main_data$IC_scaled[1:16], main_data$IC_scaled[17:24], main_data$IC_scaled[25:32], 0, main_data$IC_scaled[25:28],main_data$IC_scaled[29:32])
plot_metric("IC", emp_values_IC, "SS_IC.png", ylim_max = 1, rect_ymax = 0.4)
# 2. WS
emp_values_WS <- c(main_data$WS_scaled[1:16], main_data$WS_scaled[17:24], main_data$WS_scaled[25:32], 0, main_data$WS_scaled[25:28],main_data$WS_scaled[29:32])
plot_metric("WS", emp_values_WS, "SS_WS.png", ylim_max = 1, rect_ymax = 0.65)
```

```{r ndplot}
file_path <- "C:/Users/XinHao/Desktop/2025_SCZ_AI/simulation/"
group_levels <- c("HC", "PS", "NS", "NA", "BA", "WD")
fill_colors <- c('#66c2a5','#fc8d62','#8da0cb', 'transparent', '#e78ac3','#a6d854')

plot_metric_violin <- function(metric_name, empirical_values, filename, ylim_max, rect_ymax) {
    # empirical data
    emp_data <- data.frame(
        Group = factor(rep(group_levels, times = c(16,8,8,1,4,4)), levels = group_levels),
        exp = empirical_values
    )
    emp_summary <- emp_data %>%
        group_by(Group) %>%
        summarise(Mean = mean(exp, na.rm=TRUE), SD = sd(exp, na.rm=TRUE), .groups="drop") 
    emp_summary[emp_summary$Group == "NA", "SD"] <- 0
    print(emp_summary[, c("Group","Mean","SD")])
    
    sim_data <- read_csv(paste0(file_path, 'nd_sim_26aug.csv')) %>%
        filter(Group %in% group_levels) %>%
        mutate(Group = factor(Group, levels = group_levels))
    
    # 如果 NA 组没有数据，补占位行
    if(!"NA" %in% sim_data$Group){
        sim_data <- sim_data %>% add_row(Group=factor("NA", levels=group_levels))}
    
    p <- ggplot(data = sim_data, aes(x = Group, y = .data[[metric_name]], fill = Group)) +
        geom_violin(trim=FALSE, width=1, color=NA, adjust = 2) +
        geom_point(data = subset(emp_summary, Group != "NA"), aes(x = Group, y = Mean), size=1.25) +
        geom_errorbar(data = subset(emp_summary, Group != "NA"), 
                      aes(x=Group, ymin=Mean-SD, ymax=Mean+SD),
                      inherit.aes = FALSE, width=0.4, size=0.5, color="black") +
        theme_prism(axis_text_angle=0) +
        theme(
            legend.direction="vertical",
            axis.line=element_line(color='black', size=0.75),
            axis.ticks=element_line(color='black', size=0.75),
            axis.text=element_text(size=12, color="black", face='plain'),
            axis.title=element_text(size=14, face='plain')
        ) +
        coord_cartesian(ylim=c(0, ylim_max)) +
        scale_fill_manual(values = setNames(fill_colors, group_levels)) +
        scale_x_discrete(breaks=c("HC","PS","NS","BA","WD"), labels=c("HC","PS","NS","BA","WD")) +
        labs(x=NULL, y=metric_name) +
        geom_rect(aes(xmin=2.5, xmax=3.5, ymin=0, ymax=rect_ymax), fill=NA, color='black', linetype='dashed', size=0.5) +
        geom_rect(aes(xmin=4.5, xmax=6.5, ymin=0, ymax=rect_ymax), fill=NA, color='black', linetype='dashed', size=0.5)
    
    ggsave(filename=file.path(file_path, filename), plot=p, width=5, height=4, dpi=500)
    print(p)
}
```

## ND统计图展示
```{r showNDplot, results='asis'}
# IC
emp_values_IC <- c(main_data$IC_scaled[1:16], main_data$IC_scaled[17:24], main_data$IC_scaled[25:32],
                   0, main_data$IC_scaled[25:28], main_data$IC_scaled[29:32])
plot_metric_violin("IC", emp_values_IC, "ND_IC.png", ylim_max=1, rect_ymax=0.45)
# WS
emp_values_WS <- c(main_data$WS_scaled[1:16], main_data$WS_scaled[17:24], main_data$WS_scaled[25:32],
                   0, main_data$WS_scaled[25:28], main_data$WS_scaled[29:32])
plot_metric_violin("WS", emp_values_WS, "ND_WS.png", ylim_max=1, rect_ymax=0.7)
```

## 分布比较
```{r distribution, results='asis'}
file_path <- "C:/Users/XinHao/Desktop/2025_SCZ_AI/simulation/"
group_levels <- c("HC", "PS", "NS", "BA", "WD")
fill_colors <- c('#66c2a5','#fc8d62','#8da0cb','#e78ac3','#a6d854')

sim_data <- read_csv(paste0(file_path, 'nd_sim_26aug.csv')) %>%
  filter(Group %in% group_levels) %>%
  mutate(Group = factor(Group, levels = group_levels))

empirical_data <- data.frame(
  Group = factor(rep(c("HC", "PS", "NS", "BA", "WD"), 
                     times = c(16, 8, 8, 4, 4)), levels = group_levels),
  IC = c(main_data$IC_scaled[1:16], main_data$IC_scaled[17:24], 
         main_data$IC_scaled[25:32], main_data$IC_scaled[25:28], 
         main_data$IC_scaled[29:32]),
  WS = c(main_data$WS_scaled[1:16], main_data$WS_scaled[17:24], 
         main_data$WS_scaled[25:32], main_data$WS_scaled[25:28], 
         main_data$WS_scaled[29:32])
)

# 修正bootstrapping：每组生成1000个重采样样本点
n_boot <- 1000
kde_results <- list()

for (metric in c("IC", "WS")) {
  kde_results[[metric]] <- list()

  for (group in group_levels) {
    cat("Processing", metric, "for group", group, "\n")
    emp_original <- empirical_data[empirical_data$Group == group, metric]
    
    # 修正：从原始样本中重采样生成1000个样本点
    emp_boot <- sample(emp_original, size = n_boot, replace = TRUE)
    
    sim_data_group <- sim_data[sim_data$Group == group, metric][[1]]
    
    # 计算KDE
    bw <- bw.nrd0(c(emp_boot, sim_data_group)) * 3
    emp_kde <- density(emp_boot, bw = bw, from = 0, to = 1, n = 512)
    sim_kde <- density(sim_data_group, bw = bw, from = 0, to = 1, n = 512)
    
    # 存储结果
    kde_results[[metric]][[group]] <- list(
      empirical_kde = data.frame(x = emp_kde$x, y = emp_kde$y),
      simulated_kde = data.frame(x = sim_kde$x, y = sim_kde$y),
      empirical_data = emp_boot,  # 1000个重采样样本点
      simulated_data = sim_data_group,
      original_data = emp_original  # 保留原始数据用于参考
    )
  }
}

# 在结果中添加原始样本数量信息
for (metric in c("IC", "WS")) {
  for (group in group_levels) {
    # 获取原始样本数量
    original_n <- length(kde_results[[metric]][[group]]$original_data)
    cat("Group", group, metric, ":", original_n, "original samples ->", 
        n_boot, "bootstrap samples\n")
  }
}

# 修正距离计算函数，添加Wasserstein置换检验
calculate_distances <- function(emp_data, sim_data, n_permutations = 1000) {
  # 计算观察到的Wasserstein距离
  observed_wasserstein <- wasserstein1d(emp_data, sim_data)
  
  # 计算KS检验
  ks_test <- ks.test(emp_data, sim_data)
  
  # Wasserstein置换检验
  combined_data <- c(emp_data, sim_data)
  n_emp <- length(emp_data)
  n_total <- length(combined_data)
  
  permuted_wasserstein <- numeric(n_permutations)
  
  for (i in 1:n_permutations) {
    # 随机重排数据
    permuted_data <- sample(combined_data)
    perm_emp <- permuted_data[1:n_emp]
    perm_sim <- permuted_data[(n_emp + 1):n_total]
    
    # 计算置换后的Wasserstein距离
    permuted_wasserstein[i] <- wasserstein1d(perm_emp, perm_sim)
  }
  
  # 计算p值（单侧检验）
  wasserstein_pvalue <- mean(permuted_wasserstein >= observed_wasserstein)
  
  return(list(
    wasserstein_distance = observed_wasserstein,
    wasserstein_pvalue = wasserstein_pvalue,
    ks_statistic = ks_test$statistic,
    ks_pvalue = ks_test$p.value
  ))
}

# 分布拟合和比较
distribution_results <- data.frame()

for (metric in c("IC", "WS")) {
  for (group in group_levels) {
    # 获取模拟数据进行分布拟合
    sim_data_group <- kde_results[[metric]][[group]]$simulated_data
    
    # 拟合多种分布并选择最佳拟合
    distributions <- c("norm", "beta", "gamma", "lnorm", "weibull", "exp", "logis")
    fits <- list()
    aics <- numeric()
    
    for (i in seq_along(distributions)) {
      tryCatch({
        if (distributions[i] == "beta") {
          # Beta分布需要数据在(0,1)范围内
          scaled_data <- (sim_data_group - min(sim_data_group)) / 
                        (max(sim_data_group) - min(sim_data_group))
          scaled_data <- pmin(pmax(scaled_data, 0.001), 0.999)
          fits[[i]] <- fitdist(scaled_data, "beta")
        } else {
          fits[[i]] <- fitdist(sim_data_group, distributions[i])
        }
        aics[i] <- fits[[i]]$aic
      }, error = function(e) {
        aics[i] <- NA
      })
    }
    
    best_idx <- which.min(aics)
    best_dist <- ifelse(length(best_idx) > 0, distributions[best_idx], NA)
    
    # 计算距离指标（使用置换检验）
    emp_data <- kde_results[[metric]][[group]]$empirical_data
    sim_data_vals <- kde_results[[metric]][[group]]$simulated_data
    
    dist_metrics <- calculate_distances(emp_data, sim_data_vals, n_permutations = 1000)
    
    # 存储所有结果
    distribution_results <- rbind(distribution_results, data.frame(
      Metric = metric,
      Group = group,
      Best_Distribution = best_dist,
      Wasserstein_Distance = dist_metrics$wasserstein_distance,
      Wasserstein_Pvalue = dist_metrics$wasserstein_pvalue,
      KS_Statistic = dist_metrics$ks_statistic,
      KS_Pvalue = dist_metrics$ks_pvalue,
      Empirical_Mean = mean(emp_data),
      Simulated_Mean = mean(sim_data_vals),
      Empirical_SD = sd(emp_data),
      Simulated_SD = sd(sim_data_vals),
      Empirical_N = length(emp_data),
      Simulated_N = length(sim_data_vals)
    ))
  }
}

# 添加显著性标记
distribution_results <- distribution_results %>%
  mutate(
    WS_Significance = ifelse(Wasserstein_Pvalue < 0.001, "***",
                      ifelse(Wasserstein_Pvalue < 0.01, "**",
                      ifelse(Wasserstein_Pvalue < 0.05, "*", "n.s."))),
    KS_Significance = ifelse(KS_Pvalue < 0.001, "***",
                      ifelse(KS_Pvalue < 0.01, "**",
                      ifelse(KS_Pvalue < 0.05, "*", "n.s."))),
    # 检查p值是否合理
    Pvalue_Check = ifelse(KS_Pvalue > 1 | Wasserstein_Pvalue > 1, "ERROR: Pvalue > 1", 
                   ifelse(KS_Pvalue < 0 | Wasserstein_Pvalue < 0, "ERROR: Pvalue < 0", "OK"))
  )

# 打印详细结果
print(distribution_results)

# 检查是否有异常的p值
problematic <- distribution_results %>% filter(Pvalue_Check != "OK")
if (nrow(problematic) > 0) {
  cat("Warning: Found problematic p-values:\n")
  print(problematic)
} else {
  cat("All p-values are within valid range (0-1)\n")
}

# 绘图函数保持不变
create_bootstrap_plot <- function(metric, kde_data, y_max = NULL) {
  plot_data <- data.frame()
  for (group in group_levels) {
    group_data <- kde_data[[group]]
    emp_top <- group_data$empirical_kde %>% filter(y >= max(y) * 0.1)
    emp_df <- data.frame(Group = group, x = emp_top$x, y = emp_top$y,
                         Color = fill_colors[which(group_levels == group)])
    plot_data <- rbind(plot_data, emp_df)
  }
  
  if (is.null(y_max)) y_max <- max(plot_data$y) * 1.1
  
  p <- ggplot(plot_data, aes(x = x, y = y, fill = Group, color = Group)) +
    geom_area(position = "identity", alpha = 0.3) +
    scale_fill_manual(values = setNames(fill_colors, group_levels)) +
    scale_color_manual(values = setNames(fill_colors, group_levels)) +
    theme_prism() +
    labs(x = metric, y = "Probability Density", 
         title = paste("Bootstrap Distribution:", metric)) +
    coord_cartesian(ylim = c(0, y_max))
  return(p)
}

create_simulated_plot <- function(metric, kde_data, y_max = NULL) {
  plot_data <- data.frame()
  for (group in group_levels) {
    group_data <- kde_data[[group]]
    sim_top <- group_data$simulated_kde %>% filter(y >= max(y) * 0.1)
    sim_df <- data.frame(Group = group, x = sim_top$x, y = sim_top$y,
                         Color = fill_colors[which(group_levels == group)])
    plot_data <- rbind(plot_data, sim_df)
  }
  
  if (is.null(y_max)) y_max <- max(plot_data$y) * 1.1
  
  p <- ggplot(plot_data, aes(x = x, y = y, fill = Group, color = Group)) +
    geom_area(position = "identity", alpha = 0.3) +
    scale_fill_manual(values = setNames(fill_colors, group_levels)) +
    scale_color_manual(values = setNames(fill_colors, group_levels)) +
    theme_prism() +
    labs(x = metric, y = "Probability Density", 
         title = paste("Simulated Distribution:", metric)) +
    coord_cartesian(ylim = c(0, y_max))
  return(p)
}

# 绘制并保存图像
ic_bootstrap_plot <- create_bootstrap_plot("IC", kde_results$IC, y_max = 8)
ic_simulated_plot <- create_simulated_plot("IC", kde_results$IC, y_max = 8)
ws_bootstrap_plot <- create_bootstrap_plot("WS", kde_results$WS, y_max = 8)
ws_simulated_plot <- create_simulated_plot("WS", kde_results$WS, y_max = 8)

ggsave(filename = file.path(file_path, "distributionIC_bootstrap.png"), 
       plot = ic_bootstrap_plot, width = 10, height = 6, dpi = 500)
ggsave(filename = file.path(file_path, "distributionIC_simulated.png"), 
       plot = ic_simulated_plot, width = 10, height = 6, dpi = 500)
ggsave(filename = file.path(file_path, "distributionWS_bootstrap.png"), 
       plot = ws_bootstrap_plot, width = 10, height = 6, dpi = 500)
ggsave(filename = file.path(file_path, "distributionWS_simulated.png"), 
       plot = ws_simulated_plot, width = 10, height = 6, dpi = 500)

# 保存结果
write_csv(distribution_results, file.path(file_path, "distribution_comparison_results.csv"))

cat("Analysis completed successfully!\n")
cat("Bootstrap strategy: Each group generates", n_boot, "bootstrap means\n")
```

## 基于ND数据做后续分析
```{r reloaddata, message=FALSE, warning=FALSE}
# Load simulation data
file_path <- "C:/Users/XinHao/Desktop/2025_SCZ_AI/simulation/"
nd_data <- read_csv(paste0(file_path, 'nd_sim_26aug.csv'))
sub1data <- subset(nd_data, Group %in% c('HC', 'PS', 'NS'))
sub1data$Group <- factor(sub1data$Group, levels = c('HC', 'PS', 'NS'))
sub2data <- subset(nd_data, Group %in% c('HC', 'PS', 'BA', 'WD'))
sub2data$Group <- factor(sub2data$Group, levels = c('HC', 'PS', 'BA', 'WD'))
colors_3group <- c('HC' = '#66c2a5', 'PS' = '#fc8d62', 'NS' = '#8da0cb')
colors_4group <- c('HC' = '#66c2a5', 'PS' = '#fc8d62', 'BA' = '#e78ac3', 'WD' = '#a6d854')
```

## 相关性分析
```{r corranalysis, message=FALSE, warning=FALSE}
correlation_matrices <- list()
pvalue_matrices <- list()
groups <- unique(nd_data$Group)
for (group in groups) {
    group_data <- subset(nd_data, Group == group)
    numeric_data <- group_data[, -1] 
    cor_matrix <- matrix(NA, ncol=ncol(numeric_data), nrow=ncol(numeric_data))
    p_matrix <- matrix(NA, ncol=ncol(numeric_data), nrow=ncol(numeric_data))
    colnames(cor_matrix) <- colnames(numeric_data)
    rownames(cor_matrix) <- colnames(numeric_data)
    colnames(p_matrix) <- colnames(numeric_data)
    rownames(p_matrix) <- colnames(numeric_data)
    for (i in 1:ncol(numeric_data)) {
        for (j in i:ncol(numeric_data)) {  
            test_result <- cor.test(numeric_data[[i]], numeric_data[[j]], use='pairwise.complete.obs', method='pearson')
            cor_matrix[i, j] <- test_result$estimate
            cor_matrix[j, i] <- test_result$estimate 
            p_matrix[i, j] <- test_result$p.value
            p_matrix[j, i] <- test_result$p.value  
        }
    }
    p_matrix_adj <- p.adjust(p_matrix[lower.tri(p_matrix)], method="bonferroni")
    p_matrix[lower.tri(p_matrix)] <- p_matrix_adj
    p_matrix[upper.tri(p_matrix)] <- NA 
    correlation_matrices[[group]] <- cor_matrix
    pvalue_matrices[[group]] <- p_matrix
}

for (group in groups) {
    cat("\nCorrelation matrix for group", group, ":\n")
    lower_tri <- correlation_matrices[[group]]
    lower_tri[upper.tri(lower_tri)] <- NA
    print(lower_tri)
}
for (group in groups) {
    cat("\nBonferroni corrected P-value matrix for group", group, ":\n")
    p_matrix_formatted <- apply(pvalue_matrices[[group]], c(1,2), function(x) 
        ifelse(is.na(x), NA, formatC(x, format='f', digits=4)))
    print(p_matrix_formatted)
}
```

```{r heatmap, results='asis'}
color_palette <- colorRampPalette(c("#1E3A78", "white", "#B22222"))(200)
# 定义相关图绘图逻辑函数
plot_corr_with_stars <- function() {
  par(mfrow = c(2, 3), mar = c(2, 0.5, 2, 0.5), oma = c(1, 1, 2, 1))
  for (group in groups) {
    corr_matrix <- correlation_matrices[[group]]
    p_matrix <- pvalue_matrices[[group]]
    corrplot(corr_matrix,method = "color",type = "lower",col = color_palette,addCoef.col = "black",tl.col = "black",tl.srt = 45,number.cex = 0.8,order = "original",diag = FALSE,
             title = paste(group),mar = c(0, 0, 2, 0),addgrid.col = "grey")
    n <- nrow(corr_matrix)
    for (i in 1:n) {
      for (j in 1:n) {
        if (i > j && !is.na(p_matrix[i, j]) && p_matrix[i, j] < 0.05) {
          x_pos <- j + 0.20  #调整星号左右位置，左+右-
          y_pos <- n - i + 1 + 0.35
          stars <- ifelse(p_matrix[i, j] < 0.001, "***", ifelse(p_matrix[i, j] < 0.01, "**", "*"))
          text(x_pos, y_pos, stars, cex = 1.2, col = "black", font = 1.5)}
      }}
    abline(h = 2.5, col = "black", lty = 2, lwd = 1.5)
    }
  par(mfrow = c(1, 1), mar = c(5, 4, 4, 2) + 0.1) # 复位
}
plot_corr_with_stars()

png(filename = file.path(file_path, "Corr_Heatmap.png"), width = 2400, height = 1600, res = 300)
plot_corr_with_stars()
dev.off()
```

## GLM分析
```{r glm, message=FALSE, warning=FALSE}
create_models <- function(data) {
  IC_model <- glm(IC ~ Group * (Prior_IC + Prior_WS + IC_pcs + WS_pcs + Pr_IC + Pr_WS), 
                  data = data, family = gaussian())
  WS_model <- glm(WS ~ Group * (Prior_IC + Prior_WS + IC_pcs + WS_pcs + Pr_IC + Pr_WS),
                  data = data, family = gaussian())
  model_summary(list(IC_model, WS_model))
  return(list(IC_model = IC_model, WS_model = WS_model))
}
models1 <- create_models(sub1data)
models2 <- create_models(sub2data)
```

## 成对比较分析
```{r contrast, message=FALSE, warning=FALSE}
extract_contrasts <- function(model, vars, groups, contrasts) {
  results <- list()
  for (var in vars) {
    em <- emtrends(model, var = var, specs = ~ Group)
    contrast_results <- lapply(contrasts, function(c) contrast(em, method = list(c)))
    summary_results <- lapply(contrast_results, summary)
    p_values <- sapply(summary_results, function(res) res$p.value)
    p_values_adj <- p.adjust(p_values, method = "bonferroni")
    for (i in seq_along(summary_results)) {
      summary_results[[i]]$p.value <- p_values_adj[i]
    }
    results[[var]] <- summary_results
  }
  return(results)
}

vars <- c("Prior_IC", "Prior_WS", "IC_pcs", "WS_pcs", "Pr_IC", "Pr_WS")
outcomes <- c("IC", "WS")
contrasts_3group <- list("HC vs PS" = c(-1, 1, 0),"HC vs NS" = c(-1, 0, 1),"PS vs NS" = c(0, -1, 1))
contrasts_4group <- list(
  "HC vs PS" = c(-1, 1, 0, 0),  
  "HC vs BA" = c(-1, 0, 1, 0),
  "HC vs WD" = c(-1, 0, 0, 1),
  "PS vs BA" = c(0, -1, 1, 0),
  "PS vs WD" = c(0, -1, 0, 1),
  "BA vs WD" = c(0, 0, -1, 1)
)

results_3group_IC <- extract_contrasts(models1$IC_model, vars, sub1data$Group, contrasts_3group)
results_3group_WS <- extract_contrasts(models1$WS_model, vars, sub1data$Group, contrasts_3group)
results_4group_IC <- extract_contrasts(models2$IC_model, vars, sub2data$Group, contrasts_4group)
results_4group_WS <- extract_contrasts(models2$WS_model, vars, sub2data$Group, contrasts_4group)

print_contrast_results <- function(results) {
  for (var in names(results)) {
    cat("\nVariable:", var, "\n")
    for (contrast_name in names(results[[var]])) {
      cat("\nContrast:", contrast_name, "\n")
      print(results[[var]][[contrast_name]])
    }
  }
}
print_contrast_results(results_3group_IC)
print_contrast_results(results_3group_WS)
print_contrast_results(results_4group_IC)
print_contrast_results(results_4group_WS)
```

## 定义拟合图的函数
```{r GLMplots, message=FALSE, warning=FALSE}
create_significance_matrix <- function(results, groups, contrasts, vars) {
  significance_matrix <- matrix(0, nrow = length(groups), ncol = length(vars))
  rownames(significance_matrix) <- groups
  colnames(significance_matrix) <- vars
  for (var in vars) {
    for (contrast_name in names(contrasts)) {
      p_val <- results[[var]][[contrast_name]]$p.value  
      if (p_val < 0.05) {
        contrast_vec <- contrasts[[contrast_name]]  
        selected_groups <- which(contrast_vec != 0)  
        significance_matrix[selected_groups, var] <- 1 
      }
    }
  }
  return(significance_matrix)
}

matrix_3group_IC <- create_significance_matrix(results_3group_IC, c("HC", "PS", "NS"), contrasts_3group, vars)
matrix_3group_WS <- create_significance_matrix(results_3group_WS, c("HC", "PS", "NS"), contrasts_3group, vars)
matrix_4group_IC <- create_significance_matrix(results_4group_IC, c("HC", "PS", "BA", "WD"), contrasts_4group, vars)
matrix_4group_WS <- create_significance_matrix(results_4group_WS, c("HC", "PS", "BA", "WD"), contrasts_4group, vars)

generate_scatter_plots <- function(data, group_colors, group_name, outcome_matrix, save_path) {
  for (predictor in vars) {
    outcome_var <- sub(".*_", "", group_name)  # 提取 IC 或 WS

    relative_folder <- "simulation/plots"
    dir.create(relative_folder, showWarnings = FALSE)
    file_name <- file.path(relative_folder, paste0("scatter_", group_name, "_", predictor, ".png"))

    p <- ggplot(data, aes_string(x = predictor, y = outcome_var, color = "Group")) +
      geom_point(size = 2, alpha = 0.5, shape = 1) + 
      geom_smooth(data = subset(data, Group %in% rownames(outcome_matrix)[outcome_matrix[, predictor] == 1]),
                  method = "lm", se = FALSE, aes_string(color = "Group")) + 
      scale_color_manual(values = group_colors) +
      theme_minimal(base_family = "sans") +
      coord_cartesian(
          ylim = c(0, 1),
          xlim = if (predictor %in% c("Pr_IC", "Pr_WS")) c(0, 1.50) else c(0, 1)
      ) +
      theme(
        panel.background = element_rect(fill = "white", color = NA),
        plot.background = element_rect(fill = "white", color = NA),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.line = element_line(color = "black"),
        legend.position = "none"
      ) +
      labs(x = predictor, y = outcome_var)

    p <- ggMarginal(p, type = "density", margins = "both", groupColour = TRUE, groupFill = TRUE)
    ggsave(file_name, plot = p, width = 5, height = 5, dpi = 300)

    cat(sprintf("Group: %s | Predictor: %s | Slope:\n", group_name, predictor))
    for (group in unique(data$Group)) {
      subset_data <- subset(data, Group == group)
      model <- lm(as.formula(paste(outcome_var, "~", predictor)), data = subset_data)
      slope <- coef(model)[2]
      slopep <- summary(model)$coefficients[2, 4]
      cat(sprintf("  %s: slope=%.4f, p=%.4f\n", group, slope, slopep))
    }

    cat(sprintf("![](%s)\n\n", file_name))
  }
}
```

## 显示拟合图和斜率
```{r showGLMresults, results='asis'}
generate_scatter_plots(sub1data, colors_3group, "3group_IC", matrix_3group_IC, paste0(file_path, 'scatterplots'))
generate_scatter_plots(sub1data, colors_3group, "3group_WS", matrix_3group_WS, paste0(file_path, 'scatterplots'))
generate_scatter_plots(sub2data, colors_4group, "4group_IC", matrix_4group_IC, paste0(file_path, 'scatterplots'))
generate_scatter_plots(sub2data, colors_4group, "4group_WS", matrix_4group_WS, paste0(file_path, 'scatterplots'))
```